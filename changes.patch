 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/changelog.d/20260215_codex_reweight_optimisation.md b/changelog.d/20260215_codex_reweight_optimisation.md
new file mode 100644
index 0000000000000000000000000000000000000000..3293436a3c8469f9e33b21b06e5b1cd9c49daace
--- /dev/null
+++ b/changelog.d/20260215_codex_reweight_optimisation.md
@@ -0,0 +1,5 @@
+## Changed
+- Optimised the reweighting kernel to reuse in-place NumPy buffers, reducing temporary allocations while validating bias lengths.
+
+## Added
+- Expanded reweighter unit coverage for TRAM aliasing, input immutability, and bias validation regressions.
diff --git a/src/pmarlo/reweight/reweighter.py b/src/pmarlo/reweight/reweighter.py
index 55a17b751eb891d09a8562e793e0153c43b1b2ec..49a614efc9b13c46f66ceec363e2f5b12d835119 100644
--- a/src/pmarlo/reweight/reweighter.py
+++ b/src/pmarlo/reweight/reweighter.py
@@ -129,124 +129,140 @@ class Reweighter:
 
         splits: Dict[str, _SplitThermo] = {}
         for name, split in splits_raw.items():
             shard_id = self._coerce_shard_id(name, split)
             # Prefer canonical key w_frame, fall back to legacy 'weights'
             base_w = self._coerce_optional_array(split, "w_frame")
             if base_w is None:
                 base_w = self._coerce_optional_array(split, "weights")
             thermo = _SplitThermo(
                 shard_id=shard_id,
                 beta_sim=self._coerce_beta(split),
                 energy=self._coerce_optional_array(split, "energy"),
                 bias=self._coerce_optional_array(split, "bias"),
                 base_weights=base_w,
             )
             splits[str(name)] = thermo
         return splits
 
     def _coerce_optional_array(self, split: object, key: str) -> np.ndarray | None:
         if isinstance(split, Mapping):
             val = split.get(key)
         else:
             val = getattr(split, key, None)
         if val is None:
             return None
-        arr = np.asarray(val, dtype=np.float64).reshape(-1)
+        arr = np.array(val, dtype=np.float64, copy=False, order="C")
+        if arr.ndim != 1:
+            arr = np.reshape(arr, (-1,), order="C")
         if arr.size == 0:
             return None
         return arr
 
     def _coerce_shard_id(self, name: str, split: object) -> str:
         candidate = None
         if isinstance(split, Mapping):
             meta = split.get("meta")
             if isinstance(meta, Mapping):
                 candidate = meta.get("shard_id") or meta.get("id")
             candidate = candidate or split.get("shard_id") or split.get("id")
         else:
             candidate = getattr(split, "shard_id", None)
         if candidate is None:
             return str(name)
         return str(candidate)
 
     def _coerce_beta(self, split: object) -> float:
         beta = None
         temp = None
         if isinstance(split, Mapping):
             beta = split.get("beta")
             temp = split.get("temperature_K")
         else:
             beta = getattr(split, "beta", None)
             temp = getattr(split, "temperature_K", None)
         if beta is not None:
             beta_val = float(beta)
             if beta_val > 0 and math.isfinite(beta_val):
                 return beta_val
         if temp is not None:
             T = float(temp)
             if T > 0 and math.isfinite(T):
                 return 1.0 / (const.BOLTZMANN_CONSTANT_KJ_PER_MOL * T)
         raise ValueError("Each split must define beta or temperature_K for reweighting")
 
     def _compute_split_weights(self, thermo: _SplitThermo, mode: str) -> np.ndarray:
         # Fail-fast: energy is required (bias alone insufficient for temperature reweighting)
         if thermo.energy is None:
             raise ValueError(
                 f"Split '{thermo.shard_id}' missing required 'energy' array for reweighting"
             )
 
         n_frames = thermo.n_frames
         if n_frames <= 0:
             raise ValueError(
                 f"Split '{thermo.shard_id}' is empty (no frames) and cannot be reweighted"
             )
 
-        exponent = -(self.beta_ref - thermo.beta_sim) * thermo.energy
+        energy = thermo.energy
+        assert energy is not None
+        delta_beta = self.beta_ref - thermo.beta_sim
+        base = np.empty_like(energy, dtype=np.float64)
+        np.multiply(energy, -delta_beta, out=base, casting="unsafe")
         if thermo.bias is not None:
-            exponent -= self.beta_ref * thermo.bias
-        exponent = np.clip(
-            exponent - np.max(exponent),
+            if thermo.bias.shape[0] != n_frames:
+                raise ValueError(
+                    f"Split '{thermo.shard_id}' bias length mismatch: "
+                    f"{thermo.bias.shape[0]} != {n_frames}"
+                )
+            np.subtract(base, self.beta_ref * thermo.bias, out=base)
+
+        max_exponent = float(np.max(base))
+        np.subtract(base, max_exponent, out=base)
+        np.clip(
+            base,
             const.NUMERIC_EXP_CLIP_MIN,
             const.NUMERIC_EXP_CLIP_MAX,
+            out=base,
         )
-        base = np.exp(exponent, dtype=np.float64)
+        np.exp(base, out=base)
 
         if thermo.base_weights is not None:
             if thermo.base_weights.shape[0] != n_frames:
                 raise ValueError(
                     f"Split '{thermo.shard_id}' base_weights length mismatch: "
                     f"{thermo.base_weights.shape[0]} != {n_frames}"
                 )
-            base = base * thermo.base_weights
+            np.multiply(base, thermo.base_weights, out=base)
 
-        total = float(np.sum(base))
+        total = float(np.sum(base, dtype=np.float64))
         if not math.isfinite(total) or total <= 0.0:
             raise ValueError(
                 f"Split '{thermo.shard_id}' produced non-finite or non-positive weight sum ({total})"
             )
-        weights = base / total
+        np.divide(base, total, out=base)
+        weights = base
 
         if mode == AnalysisReweightMode.TRAM:
             # Placeholder: TRAM identical to MBAR single-ensemble for now.
             return weights.astype(np.float64, copy=False)
         return weights.astype(np.float64, copy=False)
 
     def _store_split_weights(
         self,
         dataset: AnalysisDataset,
         split_name: str,
         shard_id: str,
         weights: np.ndarray,
     ) -> None:
         if not isinstance(dataset, MutableMapping):
             return
         split_map = dataset.get("splits")
         if isinstance(split_map, MutableMapping):
             split = split_map.get(split_name)
             if isinstance(split, MutableMapping):
                 # Write canonical key
                 split["w_frame"] = weights
                 # Legacy alias for backward compatibility (do not overwrite if existing differs in length)
                 legacy = split.get("weights")
                 if legacy is None or (
                     isinstance(legacy, np.ndarray)
diff --git a/tests/unit/reweight/test_reweighter.py b/tests/unit/reweight/test_reweighter.py
index 8e14a750b490d8dddae788481b20851e748da7f8..fd20f108a71c4949d09e380624ef2a11298a24ab 100644
--- a/tests/unit/reweight/test_reweighter.py
+++ b/tests/unit/reweight/test_reweighter.py
@@ -74,25 +74,65 @@ def test_reweighter_non_positive_sum_raises():
     assert "non-finite or non-positive" in str(ei.value)
 
 
 def test_reweighter_deterministic_cache():
     energy = np.array([0.5, 0.1, 0.3], dtype=np.float64)
     ds = make_dataset(energy)
     rw = Reweighter(temperature_ref_K=300.0)
     first = rw.apply(ds)["s1"].copy()
     # Modify nothing; call again should return identical weights (byte-for-byte)
     second = rw.apply(ds)["s1"]
     assert first.shape == second.shape
     np.testing.assert_allclose(first, second, rtol=0, atol=0)
 
 
 def test_bias_changes_relative_weights():
     # Without bias: lower energy -> higher weight. Add a bias that inverts ordering.
     energy = np.array([1.0, 2.0], dtype=np.float64)
     # Bias penalize first frame strongly
     bias = np.array([10.0, 0.0], dtype=np.float64)
     ds = make_dataset(energy, bias=bias)
     rw = Reweighter(temperature_ref_K=300.0)
     w = rw.apply(ds)["s1"]
     # Second frame should now dominate
     assert w[1] > w[0]
     np.testing.assert_allclose(w.sum(), 1.0)
+
+
+def test_bias_length_mismatch_raises():
+    energy = np.array([1.0, 2.0, 3.0], dtype=np.float64)
+    bias = np.array([0.0, 0.1], dtype=np.float64)
+    ds = make_dataset(energy, bias=bias)
+    rw = Reweighter(temperature_ref_K=300.0)
+
+    with pytest.raises(ValueError) as excinfo:
+        rw.apply(ds)
+
+    assert "bias length mismatch" in str(excinfo.value)
+
+
+def test_inputs_remain_immutable_after_apply():
+    energy = np.array([0.2, 0.4, 0.6, 0.8], dtype=np.float64)
+    bias = np.array([0.0, 0.5, 1.0, 0.0], dtype=np.float64)
+    base = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float64)
+    energy_before = energy.copy()
+    bias_before = bias.copy()
+    base_before = base.copy()
+
+    ds = make_dataset(energy, bias=bias, base=base)
+    rw = Reweighter(temperature_ref_K=310.0)
+    rw.apply(ds)
+
+    np.testing.assert_allclose(energy, energy_before, rtol=0, atol=0)
+    np.testing.assert_allclose(bias, bias_before, rtol=0, atol=0)
+    np.testing.assert_allclose(base, base_before, rtol=0, atol=0)
+
+
+def test_tram_mode_matches_mbar_results():
+    energy = np.array([0.5, 0.1, 0.2], dtype=np.float64)
+    ds_tram = make_dataset(energy)
+    ds_mbar = make_dataset(energy)
+
+    tram = Reweighter(temperature_ref_K=290.0).apply(ds_tram, mode="TRAM")["s1"]
+    mbar = Reweighter(temperature_ref_K=290.0).apply(ds_mbar, mode="MBAR")["s1"]
+
+    np.testing.assert_allclose(tram, mbar, rtol=0, atol=0)
 
EOF
)