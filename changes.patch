diff --git a/src/pmarlo/transform/runner.py b/src/pmarlo/transform/runner.py
index dd7c97207e7419f2cfd24359f4dbca9e6f41b3ac..954153e498e87029ec843a15a01c21c1ec292c0f 100644
--- a/src/pmarlo/transform/runner.py
+++ b/src/pmarlo/transform/runner.py
@@ -133,149 +133,172 @@ class TransformManifest:
         ]
         self.data["failed_steps"].append(failed_step)

         self.data["status"] = "failed"
         self.save()

     def is_step_completed(self, step_name: str) -> bool:
         """Check if a step is already completed."""
         completed_steps = self.data.get("completed_steps", [])
         return any(s.get("step_name") == step_name for s in completed_steps)

     def get_last_completed_index(self) -> int:
         """Get the index of the last completed step."""
         completed_steps = self.data.get("completed_steps", [])
         if not completed_steps:
             return -1
         indices: list[int] = []
         for step in completed_steps:
             try:
                 indices.append(int(step.get("step_index", -1)))
             except Exception:
                 continue
         return max(indices) if indices else -1


+def _initialize_manifest(
+    plan: TransformPlan,
+    checkpoint_dir: Optional[str | Path],
+    run_id: Optional[str],
+) -> Optional[TransformManifest]:
+    if not checkpoint_dir:
+        return None
+    manifest = TransformManifest(Path(checkpoint_dir))
+    manifest.load()
+    if manifest.data and manifest.data.get("plan_hash") == manifest._hash_plan(plan):
+        logger.info(f"Resuming existing run {manifest.data.get('run_id')}")
+    else:
+        manifest.init_run(plan, run_id)
+    return manifest
+
+
+def _should_skip_step(
+    manifest: Optional[TransformManifest],
+    idx: int,
+    step_name: str,
+    start_index: int,
+) -> bool:
+    if manifest is None:
+        return False
+    if idx < start_index:
+        logger.info(f"Skipping completed step {idx}: {step_name}")
+        return True
+    if manifest.is_step_completed(step_name):
+        logger.info(f"Step {step_name} already completed, skipping")
+        return True
+    return False
+
+
+def _execute_step_with_retries(
+    current_data: Any,
+    step: TransformStep,
+    idx: int,
+    total_steps: int,
+    *,
+    manifest: Optional[TransformManifest],
+    reporter: ProgressReporter,
+    max_retries: int,
+) -> Any:
+    retry_count = 0
+    while retry_count <= max_retries:
+        try:
+            t0 = time.time()
+            reporter.emit(
+                "aggregate_step_start",
+                {"step_name": step.name, "index": idx + 1, "total_steps": total_steps},
+            )
+            if manifest:
+                manifest.mark_step_start(idx, step.name, step.params)
+            result = apply_transform_plan(current_data, TransformPlan(steps=(step,)))
+            duration_s = round(time.time() - t0, 3)
+            if manifest:
+                manifest.mark_step_complete(idx, step.name, {"duration_s": duration_s})
+            reporter.emit(
+                "aggregate_step_end",
+                {
+                    "step_name": step.name,
+                    "index": idx + 1,
+                    "total_steps": total_steps,
+                    "duration_s": duration_s,
+                    "current_step": idx + 1,
+                    "total_steps": total_steps,
+                },
+            )
+            return result
+        except Exception as exc:
+            retry_count += 1
+            logger.error(
+                "Step %s failed (attempt %d/%d): %s",
+                step.name,
+                retry_count,
+                max_retries + 1,
+                exc,
+            )
+            if manifest:
+                manifest.mark_step_failed(idx, step.name, str(exc))
+            if retry_count > max_retries:
+                reporter.emit("aggregate_end", {"status": "failed", "error": str(exc)})
+                raise RuntimeError(
+                    f"Step {step.name} failed after {max_retries} retries: {exc}"
+                )
+            time.sleep(min(2**retry_count, 30))
+
+
 def apply_plan(
     plan: TransformPlan,
     data: Any,
     progress_callback: Optional[ProgressCB] = None,
     checkpoint_dir: Optional[str | Path] = None,
     run_id: Optional[str] = None,
     max_retries: int = 3,
 ) -> Any:
     """Apply a transform plan step-by-step with optional checkpointing.

     Args:
         plan: The transform plan to execute
         data: Input data to transform
         progress_callback: Optional progress callback
         checkpoint_dir: Directory for checkpoint files (enables checkpointing if provided)
         run_id: Optional run identifier
         max_retries: Maximum retries per step

     Events:
       - aggregate_begin: total_steps, plan_text
       - aggregate_step_start: step_name, index, total_steps
       - aggregate_step_end: step_name, index, total_steps, duration_s, current_step, total_steps
       - aggregate_end: status
     """
     reporter = ProgressReporter(progress_callback)
     steps: list[TransformStep] = list(plan.steps)

-    # Initialize checkpointing if requested
-    manifest = None
-    if checkpoint_dir:
-        manifest = TransformManifest(Path(checkpoint_dir))
-        manifest.load()
-
-        # Check if we can resume an existing run
-        if manifest.data and manifest.data.get("plan_hash") == manifest._hash_plan(
-            plan
-        ):
-            logger.info(f"Resuming existing run {manifest.data.get('run_id')}")
-        else:
-            manifest.init_run(plan, run_id)
+    manifest = _initialize_manifest(plan, checkpoint_dir, run_id)

     reporter.emit(
         "aggregate_begin",
         {"total_steps": len(steps), "plan_text": plan_to_text(plan)},
     )

     out = data
-    n = len(steps)
+    total_steps = len(steps)
     start_index = manifest.get_last_completed_index() + 1 if manifest else 0

     for idx, step in enumerate(steps):
-        if idx < start_index:
-            logger.info(f"Skipping completed step {idx}: {step.name}")
+        if _should_skip_step(manifest, idx, step.name, start_index):
             continue
+        out = _execute_step_with_retries(
+            out,
+            step,
+            idx,
+            total_steps,
+            manifest=manifest,
+            reporter=reporter,
+            max_retries=max_retries,
+        )

-        step_name = step.name
-
-        # Check if step is already completed (idempotence)
-        if manifest and manifest.is_step_completed(step_name):
-            logger.info(f"Step {step_name} already completed, skipping")
-            continue
-
-        retry_count = 0
-        while retry_count <= max_retries:
-            try:
-                t0 = time.time()
-                reporter.emit(
-                    "aggregate_step_start",
-                    {"step_name": step_name, "index": idx + 1, "total_steps": n},
-                )
-
-                if manifest:
-                    manifest.mark_step_start(idx, step_name, step.params)
-
-                # Apply the step
-                out = apply_transform_plan(out, TransformPlan(steps=(step,)))
-
-                duration_s = round(time.time() - t0, 3)
-
-                if manifest:
-                    manifest.mark_step_complete(
-                        idx, step_name, {"duration_s": duration_s}
-                    )
-
-                reporter.emit(
-                    "aggregate_step_end",
-                    {
-                        "step_name": step_name,
-                        "index": idx + 1,
-                        "total_steps": n,
-                        "duration_s": duration_s,
-                        "current_step": idx + 1,
-                        "total_steps": n,
-                    },
-                )
-                break  # Success, exit retry loop
-
-            except Exception as e:
-                retry_count += 1
-                error_msg = f"Step {step_name} failed (attempt {retry_count}/{max_retries + 1}): {str(e)}"
-                logger.error(error_msg)
-
-                if manifest:
-                    manifest.mark_step_failed(idx, step_name, str(e))
-
-                if retry_count > max_retries:
-                    reporter.emit(
-                        "aggregate_end", {"status": "failed", "error": str(e)}
-                    )
-                    raise RuntimeError(
-                        f"Step {step_name} failed after {max_retries} retries: {str(e)}"
-                    )
-
-                # Wait before retry
-                time.sleep(min(2**retry_count, 30))  # Exponential backoff, max 30s
-
-    # Mark run as completed
     if manifest:
         manifest.data["status"] = "completed"
         manifest.data["completed_at"] = datetime.now().isoformat()
         manifest.save()

     reporter.emit("aggregate_end", {"status": "ok"})
     return out
+
